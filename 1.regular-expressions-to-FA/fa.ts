interface INode {
    [key: string]: string
}

export interface IFA {
    [key: string]: Array<INode>
}

abstract class AFA {
    _fa: IFA;

    protected constructor(fa: IFA) {
        this._fa = fa;
    }

    public abstract parseRegularExpressionInput(expression: string): void;

    public abstract parseInputStringForFA(string: string): boolean;

    protected abstract isState(state: string): boolean;

    protected abstract isTerminal(state: string): boolean;

    protected abstract parseExpression(expression: Array<string>): void;

    protected abstract traverseFA(s: string[], nextPath: Array<INode>, isStartState?: boolean): boolean;
}


// aka Finite Automaton class
export default class FA extends AFA {

    public constructor(fa: IFA) {
        super(fa);
    }

    public get fa(): IFA {
        return this._fa;
    }

    public set fa(newFA: IFA) {
        this._fa = newFA
    }

    public parseRegularExpressionInput = (expression: string): void => {
        if (expression.trim().length > 0) {
            // split expression by -> , | , space
            const arr: string[] = expression.split(/[ \->,\,|)]+/);
            this.parseExpression(arr);
        }
    };

    public parseInputStringForFA = (string: string): boolean => {
        if (string.indexOf(' ') >= 0 || string === '') return false;
        const arr: Array<string> = string.split('');
        // return bool if valid string
        // passing fa['S'], because first validation need to be made for start character node
        return this.traverseFA(arr, this._fa['S'], true);
    };

    // checks if a input character from reg-grammar is State
    protected isState = (state: string): boolean => state.toUpperCase() === state && state.toLowerCase() !== state;

    // checks if a input character from reg-grammar is terminal char (no State inside reg-grammar)
    protected isTerminal = (state: string): boolean => state.toLowerCase() === state && state.toUpperCase() !== state;

    protected parseExpression = (expresion: string[]): void => {
        // fist el is always a state
        const state: string = expresion[0];
        const p: Array<INode> = [];
        for (let i = 1; i <= expresion.length - 1; i++) {
            if (this.isTerminal(expresion[i])) {
                // if terminal
                const terminal: INode = {[`${expresion[i]}`]: 'Eps'};
                p.push(terminal);
            } else {
                // non terminal
                const arr = expresion[i].split('');
                for (let j = 0; j <= arr.length - 1; j++) {
                    if (this.isState(arr[j])) {
                        // if next state
                        const nextState: string = arr[j];
                        const alphabet: string = arr.slice(0, arr.indexOf(nextState)).join('');
                        const possible: INode = {[`${alphabet}`]: nextState};
                        p.push(possible);
                    }
                }
            }
        }
        // update fa
        if (this._fa[state] !== undefined) {
            // if state already present
            this._fa = {...this._fa, [`${state}`]: [...this._fa[state], ...p]};
        } else {
            // new state
            this._fa = {...this._fa, [`${state}`]: [...p]};
        }
    };

    // check if input [string] can be generated by traversing the FA
    protected traverseFA = (s: string[], nextPath: Array<INode>, isStartState?: boolean): boolean => {
        // if no further paths
        if (nextPath === undefined) return false;

        if (s.length === 1) {
            // if one char left => check for terminal
            for (let j = 0; j <= nextPath.length - 1; j++) {
                if (nextPath[j][s[0]] === 'Eps') {
                    console.log('➤ Terminal');
                    return true;
                }
            }
            return false;
        }

        // if length is 0 => all validations have passed
        if (s.length === 0) return true;

        // default case
        for (let i = 0; i <= nextPath.length - 1; i++) {
            // if the object with key of current char is present
            // in array of possibilities for this node (state)
            if (nextPath[i][s[0]] !== undefined) {
                if (isStartState) console.log('➤ Start S'); // only for start state
                console.log('➜', nextPath[i][s[0]]); // log next state
                // traverse again without s[0] as it was already verified
                // pass respective array for next iteration
                return this.traverseFA(s.slice(1), this._fa[nextPath[i][s[0]]]);
            }
        }

        // no matches
        return false;
    };

}