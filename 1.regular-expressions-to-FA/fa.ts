export interface pathI {
	[key: string]: string
}

export interface faI {
	[key: string]: Array<pathI>
}

// aka Finite Automaton class
export default class FA {

	private _fa: faI;

	public constructor(fa: faI) {
		this._fa = fa;
	}

	public get fa(): faI {
		return this._fa;
	}

	public set fa(newFA: faI) {
		this._fa = newFA
	}

	// checks if a input character from reg-grammar is State
	private isState = (state: string): boolean => state.toUpperCase() === state && state.toLowerCase() !== state;

	// checks if a input character from reg-grammar is terminal char (no State inside reg-grammar)
	private isTerminal = (state: string): boolean => state.toLowerCase() === state && state.toUpperCase() !== state;

	public parseRegularExpressionInput = ({grammar}: { grammar: string }): void => {
		// parse prompt input reg-grammar
		// split by -> , | , space
		const arr: string[] = grammar.split(/[ \->,\,|)]+/);
		this.parseExpression(arr);
	};

	private parseExpression = (expresion: string[]): void => {
		// fist el is always a state
		const state: string = expresion[0];
		const p: Array<pathI> = [];
		for (let i = 1; i <= expresion.length - 1; i++) {
			if (this.isTerminal(expresion[i])) {
				// if is terminal ( no state [upper case letter] in expresion )
				// add epsilon as terminal char
				const terminal: pathI = {[`${expresion[i]}`]: 'Eps'};
				p.push(terminal);
			} else {
				// non terminal char
				const arr = expresion[i].split('');
				for (let j = 0; j <= arr.length - 1; j++) {
					// if is upper char letter => is state
					if (this.isState(arr[j])) {
						// structure: { a: 'S' }
						// { alphabet : next state corresponding to this alphabet }
						const nextState: string = arr[j];
						const alphabet: string = arr.slice(0, arr.indexOf(nextState)).join('');
						const possible: pathI = {[`${alphabet}`]: nextState};
						p.push(possible);
					}
				}
			}
		}
		// update fa
		if (this._fa[state] !== undefined) {
			// if state already present
			this._fa = {...this._fa, [`${state}`]: [...this._fa[state], ...p]};
		} else {
			// new state
			this._fa = {...this._fa, [`${state}`]: [...p]};
		}
	};

	public parseInputStringForFA = ({string}): boolean => {
		// if input string has spaces
		if (string.indexOf(' ') >= 0) return false;
		// convert str to arr of chars
		const arr: Array<string> = string.split('');
		// return bool result
		// passing fa['S'], because first validation need to be made for start character node
		return this.traverseFA(arr, this._fa['S'], true);
	};

	// check if input [string] can be generated by traversing the FA
	private traverseFA = (s: string[], nextPath: Array<object>, isStartState?: boolean): boolean => {
		// if no further paths
		if (nextPath === undefined) return false;

		// if one char left => check if current state can be terminal
		if (s.length === 1) {
			for (let j = 0; j <= nextPath.length - 1; j++) {
				if (nextPath[j][s[0]] === 'Eps') {
					console.log('Terminal character');
					return true;
				}
			}
			return false;
		}

		// if length is 0 => all validations have passed
		if (s.length === 0) return true;

		// default case
		for (let i = 0; i <= nextPath.length - 1; i++) {
			// if the object with key of current char is present
			// in array of possibilities for this node (state)
			if (nextPath[i][s[0]] !== undefined) {
				if (isStartState) console.log('Start State S');
				console.log('Next State: ', nextPath[i][s[0]]);
				// traverse again without current char as it was already verified
				// pass array of possibilities for found char
				return this.traverseFA(s.slice(1), this._fa[nextPath[i][s[0]]]);
			}
		}

		// no matches
		return false;
	};

}