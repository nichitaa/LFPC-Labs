class FA {
	
	constructor(fa) {
		this.fa = fa;
	}
	
	// checks if a input character from reg-grammar is State
	isState = state => state.toUpperCase() === state && state.toLowerCase() !== state;
	
	// checks if a input character from reg-grammar is terminal char (no State inside reg-grammar)
	isTerminal = state => state.toLowerCase() === state && state.toUpperCase() !== state;
	
	parseGrammarInput = ({ grammar }) => {
		// parse prompt input reg-grammar
		// split by -> , | , space
		const arr = grammar.split(/[ \->,\,|)]+/);
		this.parseGrammar(arr);
	};
	
	parseGrammar = expresion => {
		// fist el is always a state
		const state = expresion[0];
		const p = [];
		for ( let i = 1; i <= expresion.length - 1; i++ ) {
			if ( this.isTerminal(expresion[i]) ) {
				// if is terminal ( no state [upper case letter] in expresion )
				// add epsilon as terminal char
				const terminal = { [`${expresion[i]}`]: 'Eps' };
				p.push(terminal);
			} else {
				// non terminal char
				const arr = expresion[i].split('');
				for ( let j = 0; j <= arr.length - 1; j++ ) {
					// if is upper char letter => is state
					if ( this.isState(arr[j]) ) {
						// structure: { a: 'S' }
						// { alphabet : next state corresponding to this alphabet }
						const nextState = arr[j];
						const alphabet = arr.slice(0, arr.indexOf(nextState)).join('');
						const possible = { [`${alphabet}`]: nextState };
						p.push(possible);
					}
				}
			}
		}
		// update fa
		if ( this.fa[state] !== undefined ) {
			// if state already present
			this.fa = { ...this.fa, [`${state}`]: [...this.fa[state], ...p] };
		} else {
			// new state
			this.fa = { ...this.fa, [`${state}`]: [...p] };
		}
	};
	
	parseInputStringForFA = ({ string }) => {
		// if input string has spaces
		if ( string.indexOf(' ') >= 0 ) return false;
		// convert str to arr of chars
		const arr = string.split('');
		// return bool result
		// passing fa['S'], because first validation need to be made for start character node
		return this.traverseFA(arr, this.fa['S'], true);
	};
	
	// check if input [string] can be generated by traversing the FA
	traverseFA = (s, nextPath, isStartState) => {
		// if no further paths
		if ( nextPath === undefined ) return false;
		
		// if one char left => check if current state can be terminal
		if ( s.length === 1 ) {
			for ( let j = 0; j <= nextPath.length - 1; j++ ) {
				if ( nextPath[j][s[0]] === 'Eps' ) {
					console.log('Terminal character');
					return true;
				}
			}
			return false;
		}
		
		// if length is 0 => all validations have passed
		if ( s.length === 0 ) return true;
		
		// default case
		for ( let i = 0; i <= nextPath.length - 1; i++ ) {
			// if the object with key of current char is present
			// in array of possibilities for this node (state)
			if ( nextPath[i][s[0]] !== undefined ) {
				if ( isStartState ) console.log('Start State S');
				console.log('Next State: ', nextPath[i][s[0]]);
				// traverse again without current char as it was already verified
				// pass array of possibilities for found char
				return this.traverseFA(s.slice(1), this.fa[nextPath[i][s[0]]]);
			}
		}
		
		// no matches
		return false;
	};
	
	displayFA = () => {
		console.log('Current FA:');
		console.log(this.fa);
	};
	
}

module.exports = FA;